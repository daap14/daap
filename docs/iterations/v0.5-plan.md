# Technical Plan — v0.5

## Task Order

### Phase 1: Design

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 1 | ADR 007: Tier system (replaces ADR 004 hardcoded defaults, tier lifecycle, product-team redaction) | architect | M | — |

### Phase 2: Data Layer

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 2 | Migrations: `008_create_tiers` and `009_add_tier_id_to_databases` | dev | S | 1 |
| 3 | Tier package: model, repository interface, pgx implementation, sentinel errors | dev | M | 2 |
| 4 | Update database model: add `TierID`, `TierName` fields | dev | S | 2 |
| 5 | Update database repository: tier_id in INSERT, LEFT JOIN tiers in GetByID/List | dev | S | 3, 4 |

### Phase 3: Template Refactor

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 6 | Refactor cluster template builder: remove hardcoded defaults, accept tier params (instances, CPU, memory, storage, PG version) | dev | M | 1 |
| 7 | Refactor pooler template builder: accept pool_mode and max_connections from tier | dev | S | 1 |

### Phase 4: Validation & Handler

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 8 | Tier validation: create and update validators | dev | M | 1 |
| 9 | Tier handler: POST, GET (list), GET (by ID), PATCH, DELETE with role-based response redaction | dev | L | 3, 8 |
| 10 | Update database validation: add `tier` required field | dev | S | 1 |
| 11 | Update database handler: add `tier` to create request, resolve tier, pass to builders, add `tierRepo` dependency | dev | M | 3, 5, 6, 7, 10 |

### Phase 5: Router & Wiring

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 12 | Router updates: add TierRepo to deps, platform-only group for mutations, business group for reads | dev | M | 9, 11 |
| 13 | Update `cmd/server/main.go`: init tier repo, pass to RouterDeps and DatabaseHandler | dev | S | 12 |

### Phase 6: OpenAPI & Documentation

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 14 | Update OpenAPI spec: tier tag, 5 new paths, tier schemas, update database schemas, new error code | dev | L | 9, 11, 12 |
| 15 | Update README.md: document tier system, creation flow, platform vs product views | dev | S | 14 |

### Phase 7: Tests

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 16 | Unit tests: tier repository | dev | M | 3 |
| 17 | Unit tests: tier validation | dev | S | 8 |
| 18 | Unit tests: tier handler (CRUD, role-based redaction, auth checks) | dev | L | 9 |
| 19 | Unit tests: update cluster template tests (tier params flow through) | dev | S | 6 |
| 20 | Unit tests: update pooler template tests (pool_mode, max_connections) | dev | S | 7 |
| 21 | Unit tests: update database handler tests (tier required, tier resolution, tier in response) | dev | M | 11 |
| 22 | Update integration tests: create tier before databases, add tier lifecycle tests | dev | L | 13, 14 |

### Phase 8: Review

| # | Task | Owner | Complexity | Depends On |
|---|------|-------|-----------|-----------|
| 23 | Code review: all v0.5 PRs | reviewer | L | 16–22 |

## Task Details

### Task 1: ADR 007 — Tier System
Write `docs/architecture/decisions/007-tier-system.md`. Document:
- Tiers replace hardcoded defaults from ADR 004 (`defaultInstances=1`, `defaultStorageSize=1Gi`, `defaultPGVersion="16"` in `internal/k8s/template/cluster.go`)
- Tier is required at database creation time — no default tier, no implicit fallback
- Tier fields: name, description, instances, cpu, memory, storage_size, storage_class, pg_version, pool_mode, max_connections, destruction_strategy, backup_enabled
- Tier immutability on existing databases: changing a tier's parameters does not retroactively change databases already using it
- Forward-looking columns: `destruction_strategy` and `backup_enabled` are stored but not enforced until v0.6/v0.8
- Product-team redaction: product users see only `id`, `name`, `description` — infrastructure params are hidden
- Authorization: tier mutations are platform-only (`RequireRole("platform")`); tier reads are all business users (`RequireRole("platform", "product")`)
- Status: Accepted. Supersedes ADR 004's hardcoded defaults.

### Task 2: Migrations
Create two migration files:
- `migrations/008_create_tiers.up.sql` / `.down.sql`:
  - `tiers` table with UUID PK, name (VARCHAR 63, UNIQUE), description (TEXT), instances (INT, CHECK 1–10), cpu (VARCHAR 20), memory (VARCHAR 20), storage_size (VARCHAR 20), storage_class (VARCHAR 255), pg_version (VARCHAR 10), pool_mode (VARCHAR 20, CHECK IN ('transaction','session','statement')), max_connections (INT, CHECK 10–10000), destruction_strategy (VARCHAR 20, CHECK IN ('freeze','archive','hard_delete')), backup_enabled (BOOLEAN), created_at, updated_at
  - Index on name
- `migrations/009_add_tier_id_to_databases.up.sql` / `.down.sql`:
  - Add `tier_id UUID REFERENCES tiers(id) ON DELETE RESTRICT` to databases table (nullable for backwards compat)
  - Index on tier_id

### Task 3: Tier Package
Create `internal/tier/`:
- `model.go`: `Tier` struct (ID, Name, Description, Instances, CPU, Memory, StorageSize, StorageClass, PGVersion, PoolMode, MaxConnections, DestructionStrategy, BackupEnabled, CreatedAt, UpdatedAt) + `UpdateFields` struct
- `repository.go`: `Repository` interface (Create, GetByID, GetByName, List, Update, Delete) + sentinel errors (ErrTierNotFound, ErrDuplicateTierName, ErrTierHasDatabases)
- `postgres_repository.go`: pgx implementation. Create maps `23505` → ErrDuplicateTierName. Delete maps `23503` → ErrTierHasDatabases. Update uses dynamic SET clause for non-nil fields + `updated_at = NOW()`.

### Task 4: Update Database Model
Modify `internal/database/model.go`:
- Add `TierID *uuid.UUID` to `Database` struct (pointer because pre-v0.5 databases have NULL)
- Add `TierName string` to `Database` struct (transient, populated via JOIN)
- No changes to `ListFilter`, `UpdateFields`, or `StatusUpdate`

### Task 5: Update Database Repository
Modify `internal/database/postgres_repository.go`:
- `Create()`: add `tier_id` to INSERT column list and values
- `GetByID()`: add `LEFT JOIN tiers t ON d.tier_id = t.id` to query, scan `t.name` into `TierName`
- `List()`: same LEFT JOIN, same scan
- Add `ErrInvalidTier` sentinel error for FK violation on tier_id (PG code `23503` on the tier FK)

### Task 6: Refactor Cluster Template Builder
Modify `internal/k8s/template/cluster.go`:
- Remove `defaultInstances`, `defaultStorageSize`, `defaultPGVersion` constants
- Expand `ClusterParams` to include: `Instances int`, `CPU string`, `Memory string`, `StorageSize string`, `StorageClass string`, `PGVersion string`
- `BuildCluster()` uses `params.Instances` for `spec.instances`, `params.StorageSize` for `spec.storage.size`, `params.PGVersion` for image name, `params.CPU`/`params.Memory` for `spec.resources.requests` and `spec.resources.limits`
- If `params.StorageClass != ""`, set `spec.storage.storageClassName`
- If `params.PGVersion == ""`, panic or error — no more silent default

### Task 7: Refactor Pooler Template Builder
Modify `internal/k8s/template/pooler.go`:
- Expand `PoolerParams` to include: `PoolMode string`, `MaxConnections int`
- `BuildPooler()` uses `params.PoolMode` for `spec.pgbouncer.poolMode` and `params.MaxConnections` for `spec.pgbouncer.parameters.default_pool_size` (string-formatted int)

### Task 8: Tier Validation
Create `internal/api/validation/tier.go`:
- `CreateTierRequest` struct: Name, Description, Instances, CPU, Memory, StorageSize, StorageClass, PGVersion, PoolMode, MaxConnections, DestructionStrategy, BackupEnabled
- `ValidateCreateTierRequest()` → `[]FieldError`: validates all fields per spec (name regex, instances 1–10, K8s resource patterns, pg_version enum, pool_mode enum, max_connections 10–10000, destruction_strategy enum)
- `UpdateTierRequest` struct: all fields as pointers (optional)
- `ValidateUpdateTierRequest()` → `[]FieldError`: validates only non-nil fields, same rules
- Reuse `nameRegex` from `database.go` (export it or duplicate — prefer exporting as `NameRegex`)

### Task 9: Tier Handler
Create `internal/api/handler/tier.go`:
- `TierHandler` struct with `repo tier.Repository`
- `Create(w, r)`: MaxBytesReader → decode → TrimSpace name → validate → repo.Create → 201 (full response)
- `List(w, r)`: repo.List → check role → platform: full `tierResponse` list; product: `tierSummaryResponse` list → 200 list envelope
- `GetByID(w, r)`: parse UUID → repo.GetByID → check role → platform: full; product: summary → 200
- `Update(w, r)`: parse UUID → decode → reject `name` (immutable) → validate → repo.Update → 200 (full response)
- `Delete(w, r)`: parse UUID → repo.Delete → 204 or 409 `TIER_HAS_DATABASES`
- Role detection: use `middleware.GetIdentity(ctx)` → check `identity.Role` for "product" to decide response shape

### Task 10: Update Database Validation
Modify `internal/api/validation/database.go`:
- Add `Tier string` field to `CreateDatabaseRequest`
- Add validation: if `Tier == ""` → `FieldError{Field: "tier", Message: "tier is required"}`

### Task 11: Update Database Handler
Modify `internal/api/handler/database.go`:
- Add `tierRepo tier.Repository` to `DatabaseHandler` struct
- Update `NewDatabaseHandler` to accept `tierRepo`
- Add `Tier string` to `createDatabaseRequest`
- Add `Tier string` to `databaseResponse`
- In `Create()`:
  1. TrimSpace tier name
  2. Validate (tier required — already handled by updated validation)
  3. Resolve tier: `tierRepo.GetByName(req.Tier)` → if not found → 404 "Tier not found"
  4. Build ClusterParams from tier: `{Name: db.Name, Namespace: namespace, Instances: resolvedTier.Instances, CPU: resolvedTier.CPU, Memory: resolvedTier.Memory, StorageSize: resolvedTier.StorageSize, StorageClass: resolvedTier.StorageClass, PGVersion: resolvedTier.PGVersion}`
  5. Build PoolerParams from tier: `{Name: db.Name, Namespace: namespace, ClusterName: db.ClusterName, PoolMode: resolvedTier.PoolMode, MaxConnections: resolvedTier.MaxConnections}`
  6. Set `db.TierID = &resolvedTier.ID`
- In `toDatabaseResponse()`: set `Tier: db.TierName`

### Task 12: Router Updates
Modify `internal/api/router.go`:
- Add `TierRepo tier.Repository` to `RouterDeps`
- Add tier handler initialization: `tierHandler := handler.NewTierHandler(deps.TierRepo)`
- Business group (RequireRole("platform", "product")): add `GET /tiers` and `GET /tiers/{id}`
- New platform-only group (RequireRole("platform")): add `POST /tiers`, `PATCH /tiers/{id}`, `DELETE /tiers/{id}`
- Update `NewDatabaseHandler` call to pass `deps.TierRepo`

### Task 13: Main.go Wiring
Modify `cmd/server/main.go`:
- `tierRepo := tier.NewPostgresRepository(pool)`
- Add `TierRepo: tierRepo` to `RouterDeps`

### Task 14: OpenAPI Spec Update
Update `api/openapi.yaml`:
- Add `tiers` tag
- Add 5 paths: POST/GET /tiers, GET/PATCH/DELETE /tiers/{id}
- Add schemas: Tier (full, 15 fields), TierSummary (3 fields), CreateTierRequest, UpdateTierRequest, TierResponse, TierSummaryResponse, TierListResponse
- Update CreateDatabaseRequest: add required `tier` (string)
- Update Database schema: add `tier` (string)
- Add error code `TIER_HAS_DATABASES` to error code enum
- Add 401/403 responses to all tier endpoints
- Note in descriptions: product users receive TierSummary, platform users receive full Tier

### Task 15: README Update
Add Tier System section to README.md:
- What tiers are and why they exist
- How platform users create and manage tiers
- How product users view tiers (redacted)
- How databases reference tiers
- Example curl commands for tier CRUD

### Tasks 16–22: Tests
Follow existing patterns in `tests/unit/` hierarchy:

**Task 16**: `tests/unit/tier/repository_test.go` — Create (success, duplicate name), GetByID (found, not found), GetByName (found, not found), List (empty, multiple), Update (success, not found, partial fields), Delete (success, not found, has databases)

**Task 17**: `tests/unit/api/validation/tier_test.go` — Table-driven tests for all create fields (name regex, instances bounds, cpu format, memory format, storage format, pg_version enum, pool_mode enum, max_connections bounds, destruction_strategy enum). Update validation for partial fields.

**Task 18**: `tests/unit/api/handler/tier_test.go` — Create (valid, validation error, duplicate name), List (platform sees full, product sees summary), GetByID (found, not found, product redaction), Update (valid, immutable name, not found), Delete (success, not found, has databases). Auth checks (missing key → 401, wrong role → 403, superuser → 403).

**Task 19**: `tests/unit/k8s/template/cluster_test.go` — Update existing tests: verify all ClusterParams fields map to CNPG Cluster spec (instances, storage size, storage class when present, PG version in image, CPU/memory in resources).

**Task 20**: `tests/unit/k8s/template/pooler_test.go` — Update existing tests: verify PoolMode maps to pgbouncer.poolMode, MaxConnections maps to pgbouncer parameters.

**Task 21**: `tests/unit/api/handler/database_test.go` — Update existing create tests: `tier` required (400 if missing), tier resolution (404 if not found), tier name in response. Update mock handler to include tier repo.

**Task 22**: `tests/integration/api/` — Update existing tests to create a tier before creating databases. Add tier lifecycle tests: create tier → list (platform full, product redacted) → get → update → create database with tier → cannot delete tier with database → delete database → delete tier. Product user mutation rejection (403).

### Task 23: Code Review
Reviewer reviews all v0.5 PRs on GitHub:
- Verify tier CRUD follows existing patterns (team handler as reference)
- Verify role-based redaction is correct (product users never see infra params)
- Verify template builders no longer have hardcoded defaults
- Verify database creation flow: tier name → resolve → tier params → builders
- Verify OpenAPI spec matches implementation
- Capture any new patterns as `.claude/rules/` updates

## Dependency Graph

```
Task 1 (ADR)
├── Task 2 (migrations)
│   ├── Task 3 (tier pkg) ──── Task 16 (tier repo tests)
│   │   ├── Task 5 (db repo update) ─┐
│   │   └── Task 9 (tier handler) ──── Task 18 (tier handler tests)
│   │       │
│   └── Task 4 (db model update)─────┘
│                                     │
├── Task 6 (cluster template) ──── Task 19 (cluster template tests)
│   │
├── Task 7 (pooler template) ──── Task 20 (pooler template tests)
│   │
├── Task 8 (tier validation) ──── Task 17 (tier validation tests)
│   │   └── Task 9 (tier handler)
│   │
└── Task 10 (db validation update)
    └── Task 11 (db handler update) ──── Task 21 (db handler tests)
        │   (depends on: 3, 5, 6, 7, 10)
        │
        └── Task 12 (router)
            │   (depends on: 9, 11)
            └── Task 13 (main.go)
                └── Task 14 (OpenAPI) ── Task 15 (README)
                    └── Task 22 (integration tests)
                                            └── Task 23 (review)
```

**Critical path**: 1 → 2 → 3 → 5 → 11 → 12 → 13 → 14 → 22 → 23 (10 tasks deep)

## PR Strategy

v0.5 is delivered as **multiple sequential PRs** merged to `master`:

| PR | Tasks | Branch | Description |
|----|-------|--------|-------------|
| PR A | 1 | `docs/tier-system-adr` | ADR 007 only |
| PR B | 2, 3, 4, 5, 16 | `feat/tier-data-layer` | Migrations + tier pkg + database model/repo updates + tier repo tests |
| PR C | 6, 7, 19, 20 | `refactor/tier-templates` | Template builder refactor + updated template tests |
| PR D | 8, 9, 10, 11, 12, 13, 17, 18, 21 | `feat/tier-handlers-router` | Validation + handlers + router + main.go wiring + unit tests |
| PR E | 14, 15, 22 | `chore/tier-openapi-docs-tests` | OpenAPI spec + README + integration tests |

Each PR is reviewed (task 23) before merge. PRs are sequential — each depends on the previous being merged.

**Merge order matters**: PR B must land before PR C (template refactor needs tier model). PR C must land before PR D (handlers need updated builders). PR D must land before PR E (OpenAPI and integration tests need working endpoints).

## Open Questions

None — ADR 007 (task 1) resolves all open design decisions. The spec already addresses:
- Tier field set and types
- Authorization model (platform mutations, business reads, product redaction)
- Backwards compatibility (nullable tier_id for pre-v0.5 databases)
- Forward-looking columns (destruction_strategy, backup_enabled stored but not enforced)

## Risks

| Risk | Mitigation |
|------|-----------|
| Template builder refactor breaks existing tests | PR C includes updated template tests. Run `make test` after refactor to catch issues early. |
| Existing integration tests break when `POST /databases` requires `tier` | PR E updates integration tests to create a tier first. During development, run unit tests for intermediate PRs. |
| Role-based response redaction adds complexity to tier handler | Follow existing `isProductUser()` pattern from database handler. Keep it simple: one `if` branch per endpoint, two response struct types. |
| `nameRegex` needs to be shared between database and tier validation | Export as `NameRegex` or duplicate. Prefer exporting — single source of truth. |
| Tier update with dynamic SET clause is more complex than team/user (which have no update) | Use the same dynamic query building pattern as `database.Update()` which already handles optional fields. |

## Summary

| Metric | Value |
|--------|-------|
| Total tasks | 23 |
| architect | 1 task (ADR) |
| dev | 21 tasks (data layer, handlers, templates, tests) |
| reviewer | 1 task (review all PRs) |
| local-devops | 0 tasks (no infra changes needed) |
| PRs | 5 sequential PRs |
| Critical path depth | 10 tasks |
| New files | ~12 (2 migrations × 2 files, 3 tier pkg files, 2 validation/handler files, ~3 test files, 1 ADR) |
| Modified files | ~12 (database model, database repo, database handler, database validation, cluster template, pooler template, router, main.go, openapi.yaml, README, existing test files) |
