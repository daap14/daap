# Iteration v0.4 — Authentication, User Management, and RBAC

## Goal
Introduce a user management system with API key authentication and role-based access control. A superuser manages teams and users; teams carry a hardcoded role (`platform` or `product`) that governs what their users can do on business endpoints.

## Domain Model

```
Superuser (teamless, no role)
  └── manages Teams and Users

Team
  ├── name: string (unique)
  ├── role: "platform" | "product"   (hardcoded, assigned at creation)
  └── has many Users

User
  ├── name: string
  ├── team_id: FK → teams.id   (required, except superuser)
  ├── api_key_prefix: string    (first 8 chars, for lookup)
  ├── api_key_hash: string      (bcrypt, never plaintext)
  └── is_superuser: bool        (only one, auto-bootstrapped)
```

### Authorization matrix

| Caller | `/teams` | `/users` | `/databases` | `/health`, `/openapi.json` |
|--------|----------|----------|--------------|---------------------------|
| **Superuser** | Full CRUD | Full CRUD | **No access** (403) | Public |
| **Platform user** | No access (403) | No access (403) | Full access (all databases) | Public |
| **Product user** | No access (403) | No access (403) | Own team's databases only | Public |
| **Unauthenticated** | 401 | 401 | 401 | Public |

Key principle: the superuser is an admin-only identity. It cannot create databases or perform any business operation. Platform and product users cannot manage teams or users.

## Features

- [ ] **ADR 006 — Auth strategy**: Write `docs/architecture/decisions/006-auth-strategy.md`
  - API key hashing: bcrypt (cost=12) — sufficient for high-entropy keys, simpler than argon2id in Go
  - Key format: 32 random bytes → base64url encoding, prefixed with `daap_`
  - Key prefix: first 8 chars stored plaintext for efficient lookup (avoids O(n) bcrypt per request)
  - Header: `X-API-Key`
  - User model: superuser (teamless) + teams with roles + users with API keys
  - Middleware stack: RequestID → Recovery → Auth → AuthZ → Logger → handler
  - Superuser bootstrap: auto-created on first startup when `users` table is empty

- [ ] **Migrations**: Two new tables
  - Migration `004_create_teams.sql`:
    ```sql
    -- up
    CREATE TABLE teams (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL UNIQUE,
        role VARCHAR(20) NOT NULL CHECK (role IN ('platform', 'product')),
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- down
    DROP TABLE IF EXISTS teams;
    ```
  - Migration `005_create_users.sql`:
    ```sql
    -- up
    CREATE TABLE users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        team_id UUID REFERENCES teams(id) ON DELETE RESTRICT,
        is_superuser BOOLEAN NOT NULL DEFAULT FALSE,
        api_key_prefix VARCHAR(8) NOT NULL,
        api_key_hash VARCHAR(255) NOT NULL,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        revoked_at TIMESTAMPTZ
    );
    CREATE UNIQUE INDEX idx_users_superuser ON users (is_superuser) WHERE is_superuser = TRUE;
    CREATE INDEX idx_users_api_key_prefix ON users (api_key_prefix) WHERE revoked_at IS NULL;
    CREATE INDEX idx_users_team_id ON users (team_id);

    -- down
    DROP TABLE IF EXISTS users;
    ```
  - `idx_users_superuser` partial unique index ensures at most one superuser row
  - `team_id` is nullable at DB level (superuser has NULL), but application enforces non-null for all other users
  - `ON DELETE RESTRICT` on `team_id` — cannot delete a team that has users

- [ ] **Team model and repository**: `internal/team/`
  - `model.go`:
    ```go
    type Team struct {
        ID        uuid.UUID
        Name      string
        Role      string // "platform" or "product"
        CreatedAt time.Time
        UpdatedAt time.Time
    }
    ```
  - `repository.go` — interface:
    ```go
    type Repository interface {
        Create(ctx context.Context, team *Team) error
        GetByID(ctx context.Context, id uuid.UUID) (*Team, error)
        List(ctx context.Context) ([]Team, error)
        Delete(ctx context.Context, id uuid.UUID) error
    }
    ```
  - Sentinel errors: `ErrTeamNotFound`, `ErrDuplicateTeamName`, `ErrTeamHasUsers`
  - `postgres_repository.go` — pgx implementation
  - Delete checks for existing users referencing the team (or relies on FK RESTRICT and maps the PG error)

- [ ] **User model and auth service**: `internal/auth/`
  - `model.go`:
    ```go
    type User struct {
        ID           uuid.UUID
        Name         string
        TeamID       *uuid.UUID  // nil for superuser
        IsSuperuser  bool
        ApiKeyPrefix string
        ApiKeyHash   string
        CreatedAt    time.Time
        RevokedAt    *time.Time
    }

    // Identity is stored in request context after authentication
    type Identity struct {
        UserID      uuid.UUID
        UserName    string
        TeamID      *uuid.UUID  // nil for superuser
        TeamName    *string     // nil for superuser
        Role        *string     // nil for superuser; "platform" or "product"
        IsSuperuser bool
    }
    ```
  - `repository.go` — interface:
    ```go
    type UserRepository interface {
        Create(ctx context.Context, user *User) error
        GetByID(ctx context.Context, id uuid.UUID) (*User, error)
        FindByPrefix(ctx context.Context, prefix string) ([]User, error)
        List(ctx context.Context) ([]User, error)
        Revoke(ctx context.Context, id uuid.UUID) error
        CountAll(ctx context.Context) (int, error)
    }
    ```
  - Sentinel errors: `ErrUserNotFound`, `ErrUserRevoked`
  - `CountAll` used at startup to detect first-run (empty table → bootstrap superuser)
  - `FindByPrefix` returns active (non-revoked) users matching `api_key_prefix`; caller verifies bcrypt hash
  - `service.go`:
    ```go
    type Service struct {
        userRepo UserRepository
        teamRepo team.Repository
        bcryptCost int
    }

    func (s *Service) GenerateKey() (rawKey, prefix, hash string, err error)
    func (s *Service) Authenticate(ctx context.Context, rawKey string) (*Identity, error)
    func (s *Service) BootstrapSuperuser(ctx context.Context) (rawKey string, err error)
    ```
  - `GenerateKey()`: 32 random bytes → base64url → prepend `daap_` → prefix = first 8 chars of full key → bcrypt hash
  - `Authenticate()`: extract prefix → `FindByPrefix` → bcrypt compare each candidate → if match, join with team to build `Identity`
  - `BootstrapSuperuser()`: called at startup if `CountAll() == 0`; creates a superuser user (no team), logs the raw key once via `slog.Info("Superuser API key created", "key", rawKey)`. Key is only printed this one time.

- [ ] **Team handler**: `internal/api/handler/team.go` — superuser-only
  - `POST /teams` — create a team
    - Request body: `{"name": "...", "role": "platform|product"}`
    - Validates: `name` required (max 255 chars), `role` required and must be `platform` or `product`
    - Returns 201: `{"data": {"id": "uuid", "name": "...", "role": "...", "createdAt": "...", "updatedAt": "..."}, ...}`
    - Error codes: `VALIDATION_ERROR` (400), `DUPLICATE_NAME` (409)
  - `GET /teams` — list all teams
    - Returns 200 with list envelope (no pagination — team count expected to be small)
    - Response: `{"data": [{"id": "...", "name": "...", "role": "...", "createdAt": "...", "updatedAt": "..."}], ...}`
  - `DELETE /teams/{id}` — delete a team
    - Fails if team has active (non-revoked) users → 409 `TEAM_HAS_USERS`
    - Returns 204 on success
    - Error codes: `INVALID_ID` (400), `NOT_FOUND` (404), `TEAM_HAS_USERS` (409)

- [ ] **User handler**: `internal/api/handler/user.go` — superuser-only
  - `POST /users` — create a user
    - Request body: `{"name": "...", "teamId": "uuid"}`
    - Validates: `name` required (max 255 chars), `teamId` required and must reference an existing team
    - Generates API key via `auth.Service.GenerateKey()`
    - Returns 201 with the raw API key (only time it's visible): `{"data": {"id": "uuid", "name": "...", "teamId": "uuid", "teamName": "...", "role": "...", "apiKey": "daap_...", "createdAt": "..."}, ...}`
    - Error codes: `VALIDATION_ERROR` (400), `NOT_FOUND` (404, if teamId doesn't exist)
  - `GET /users` — list all users
    - Returns 200 with list envelope (no pagination)
    - Response includes: id, name, teamId, teamName, role, apiKeyPrefix, isSuperuser, createdAt, revokedAt — never the raw key or hash
  - `DELETE /users/{id}` — revoke a user (soft-revoke)
    - Sets `revoked_at = NOW()` — does not hard-delete (audit trail)
    - Cannot revoke the superuser → 403 `FORBIDDEN` with message "Cannot revoke the superuser"
    - Returns 204 on success
    - Error codes: `INVALID_ID` (400), `NOT_FOUND` (404), `FORBIDDEN` (403)

- [ ] **Authentication middleware**: `internal/api/middleware/auth.go`
  - Extracts `X-API-Key` header value
  - Missing or empty → 401 `UNAUTHORIZED` with message "API key is required"
  - Calls `auth.Service.Authenticate(rawKey)` → resolves to `Identity` (includes user, team, role info)
  - Invalid/revoked → 401 `UNAUTHORIZED` with message "Invalid or revoked API key"
  - On success: stores `Identity` in request context via `context.WithValue`
  - Helper: `GetIdentity(ctx context.Context) *Identity` — retrieves from context
  - Not applied to `/health` and `/openapi.json` (these routes are in a separate public Chi group)

- [ ] **Authorization middleware**: `internal/api/middleware/authz.go`
  - `RequireSuperuser() func(http.Handler) http.Handler` — rejects non-superuser with 403
  - `RequireRole(roles ...string) func(http.Handler) http.Handler` — rejects if identity's team role is not in `roles`; also rejects superuser (superuser has no role and cannot access business endpoints)
  - Applied per route group in router:
    - `/teams` routes: `RequireSuperuser()`
    - `/users` routes: `RequireSuperuser()`
    - `/databases` routes: `RequireRole("platform", "product")` (blocks superuser, blocks unauthenticated)

- [ ] **Ownership scoping on database endpoints**: Modify `internal/api/handler/database.go`
  - `POST /databases`: Product users — `ownerTeam` in request body must match `Identity.TeamName`; if omitted, auto-set to `Identity.TeamName`. Platform users can set any `ownerTeam`. Mismatch → 403 `FORBIDDEN` "Cannot create databases for another team".
  - `GET /databases` (List): Product users — auto-inject `owner_team` filter matching `Identity.TeamName` (overrides query param). Platform users see all.
  - `GET /databases/{id}`: Product users — if `db.OwnerTeam != identity.TeamName` → 404 `NOT_FOUND` (not 403). Platform users see all.
  - `PATCH /databases/{id}`: Same ownership check as GET. Product users cannot change `ownerTeam` at all (403 `FORBIDDEN`). Platform users can change `ownerTeam` to any value.
  - `DELETE /databases/{id}`: Same ownership check. Product users can only delete own databases.

- [ ] **Validation**: `internal/api/validation/team.go` and `internal/api/validation/user.go`
  - Team: `name` required, max 255 chars; `role` required, must be `platform` or `product`
  - User: `name` required, max 255 chars; `teamId` required, must be valid UUID format
  - Both return `[]FieldError` (same pattern as existing database validation)

- [ ] **Router restructure**: `internal/api/router.go`
  - ```
    Public group (no auth):
      GET /health
      GET /openapi.json

    Authenticated group (auth middleware):
      Superuser-only group (RequireSuperuser):
        POST   /teams
        GET    /teams
        DELETE /teams/{id}
        POST   /users
        GET    /users
        DELETE /users/{id}

      Business group (RequireRole("platform", "product")):
        POST   /databases
        GET    /databases
        GET    /databases/{id}
        PATCH  /databases/{id}
        DELETE /databases/{id}
    ```
  - `RouterDeps` struct gains: `AuthService *auth.Service`, `TeamRepo team.Repository`, `UserRepo auth.UserRepository`

- [ ] **Superuser bootstrap in main.go**: `cmd/server/main.go`
  - After DB pool init and migrations: call `authService.BootstrapSuperuser(ctx)`
  - If users table is empty → creates superuser, logs key
  - If users table is not empty → no-op (idempotent on restart)

- [ ] **Update OpenAPI spec**: Add to `api/openapi.yaml`:
  - Security scheme: `ApiKeyAuth` (type: `apiKey`, in: `header`, name: `X-API-Key`)
  - Global `security: [{ApiKeyAuth: []}]` — applied to all paths
  - Override on `/health` and `/openapi.json`: `security: []` (public)
  - New tag: `teams` (superuser-only team management)
  - New tag: `users` (superuser-only user management)
  - New paths: `POST /teams`, `GET /teams`, `DELETE /teams/{id}`, `POST /users`, `GET /users`, `DELETE /users/{id}`
  - New schemas: `Team`, `CreateTeamRequest`, `TeamResponse`, `TeamListResponse`, `User` (metadata only), `UserWithApiKey` (creation response), `CreateUserRequest`, `UserResponse`, `UserWithApiKeyResponse`, `UserListResponse`
  - New error codes in `ResponseError.code` enum: `UNAUTHORIZED`, `FORBIDDEN`, `TEAM_HAS_USERS`
  - Add 401 and 403 responses to all authenticated endpoints

- [ ] **Update existing integration tests**: All existing database and health integration tests must set up a platform-role user with API key and pass `X-API-Key` header

- [ ] **New unit tests** (in `tests/unit/`):
  - `auth/service_test.go` — key generation, authentication (valid, invalid, revoked, superuser), prefix matching, bootstrap
  - `auth/repository_test.go` — user CRUD, sentinel errors, FindByPrefix
  - `team/repository_test.go` — team CRUD, duplicate name, delete with users
  - `api/handler/team_test.go` — create, list, delete, validation, auth errors
  - `api/handler/user_test.go` — create, list, revoke, validation, auth errors, cannot revoke superuser
  - `api/middleware/auth_test.go` — missing key, invalid key, revoked key, valid key
  - `api/middleware/authz_test.go` — superuser access, role checks, superuser blocked from business routes

- [ ] **New integration tests** (in `tests/integration/api/`):
  - `auth_test.go` — full lifecycle: superuser creates team → creates user → user authenticates → user accesses databases → revoke user → user rejected
  - `database_ownership_test.go` — product user creates DB (sees only own), platform user sees all, cross-team access returns 404, superuser gets 403 on database endpoints

- [ ] **Config updates**: `internal/config/config.go`
  - Add `BcryptCost int` with `envconfig:"BCRYPT_COST" default:"12"`
  - Update `.env.example` with `BCRYPT_COST`

- [ ] **README.md update**: Document user management model (superuser, teams, roles, users), `X-API-Key` header, bootstrap process, new endpoints

- [ ] **Rule file**: `.claude/rules/auth.md` — conventions for auth middleware, ownership scoping, superuser constraints, key handling

## Codebase Impact

| Area | Current State | Changes Needed |
|------|--------------|----------------|
| `internal/api/handler/` | 3 files: `health.go`, `database.go`, `openapi.go` | Add `team.go`, `user.go` |
| `internal/api/middleware/` | 2 files: `requestid.go`, `recovery.go` | Add `auth.go`, `authz.go` |
| `internal/api/validation/` | 1 file: `database.go` | Add `team.go`, `user.go` |
| `internal/api/router.go` | Flat route registration, no auth groups | Restructure into public / superuser / business groups with middleware |
| `internal/api/handler/database.go` | No auth awareness | Add ownership scoping via `middleware.GetIdentity(ctx)` |
| `internal/database/model.go` | `ListFilter.OwnerTeam *string` | No change — ownership filtering already supported |
| `internal/team/` | Does not exist | New package: `model.go`, `repository.go`, `postgres_repository.go` |
| `internal/auth/` | Does not exist | New package: `model.go`, `repository.go`, `postgres_repository.go`, `service.go` |
| `internal/config/config.go` | 7 env vars | Add `BcryptCost` |
| `cmd/server/main.go` | Inits DB, K8s, router, reconciler | Add: init team repo, user repo, auth service, superuser bootstrap |
| `migrations/` | 3 files (001–003) | Add `004_create_teams.sql`, `005_create_users.sql` |
| `api/openapi.yaml` | 963 lines, 6 endpoints, 9 error codes | Add security scheme, 6 new paths, ~10 new schemas, 3 new error codes, 401/403 on all auth'd endpoints |
| `tests/unit/` | 12 test files | Add ~7 new test files |
| `tests/integration/api/` | 2 files | Add `auth_test.go`, `database_ownership_test.go`; update existing tests |
| `go.mod` | `golang.org/x/crypto` indirect | Promote to direct (for `bcrypt`) |
| `.env.example` | 7 vars | Add `BCRYPT_COST` |

## New Dependencies

| Module | Purpose | Notes |
|--------|---------|-------|
| `golang.org/x/crypto` | `bcrypt` package for API key hashing | Already an indirect dep via K8s client libs — promoted to direct |

No new external services or infrastructure needed. Auth is purely application-level using the existing platform database.

## Non-Goals

- OAuth2 / JWT / OIDC — API keys are sufficient for a platform-internal service
- Key rotation / automatic expiry — keys are manually revoked; TTL deferred
- Rate limiting per user — deferred
- Per-resource ACLs beyond team ownership — two roles are sufficient for v1
- Team CRUD beyond create/list/delete (no update) — renaming a team is not needed for v1
- User update (name change, team reassignment) — revoke + recreate is sufficient
- Pagination on `/teams` and `/users` — expected counts are small (< 100)
- Audit logging of auth events — deferred to v0.9 (Security Defaults)
- Multiple API keys per user — one key per user for simplicity

## Dependencies

- **v0.3** (shipped): OpenAPI tooling in place; all new endpoints must include OpenAPI definitions
- **ADR 006**: Auth strategy decision (first task of this iteration)
- `golang.org/x/crypto/bcrypt`: already indirect dep, promoted to direct
- Existing platform database (PostgreSQL 16 via pgx) for `teams` and `users` tables

## Corrections from Roadmap

| Roadmap Description | Resolution |
|--------------------|------------|
| Roadmap has a flat `api_keys` table with `team_name` and `role` columns — team identity baked into the key | Replaced with proper entity model: `teams` table (name + role) + `users` table (name + team FK + API key hash). Cleaner separation, supports team management. |
| Roadmap says "POST/GET/DELETE /api-keys (platform-team only)" | Replaced with `POST/GET/DELETE /teams` + `POST/GET/DELETE /users` — both superuser-only. No `/api-keys` endpoints. |
| Roadmap has no concept of superuser — platform-team role manages keys | Added superuser as a distinct teamless identity that manages teams and users but cannot perform business operations. This prevents circular bootstrapping (who creates the first platform-team key?). |
| Roadmap says key prefix for efficient lookup | Preserved: `api_key_prefix` column on `users` table with partial index on active (non-revoked) users |
| Roadmap says "bcrypt/argon2" | bcrypt (cost=12). Decision in ADR 006. |
| Roadmap says roles are `platform-team` / `product-team` | Simplified to `platform` / `product` (the `-team` suffix is redundant since the role lives on the team entity) |

## Acceptance Criteria

- `make build` succeeds with `golang.org/x/crypto`, `internal/auth/`, and `internal/team/`
- `make test` passes, including all new unit tests and updated integration tests
- `make lint` passes with no new warnings
- `make lint-openapi` passes with the updated `api/openapi.yaml`
- **Bootstrap**: On first startup with empty DB (after migrations), server logs a superuser API key exactly once
- **Superuser team management**: `curl -X POST localhost:8080/teams -H "X-API-Key: $SUPERUSER_KEY" -d '{"name":"ops","role":"platform"}'` returns 201
- **Superuser user creation**: `curl -X POST localhost:8080/users -H "X-API-Key: $SUPERUSER_KEY" -d '{"name":"alice","teamId":"<ops-team-id>"}'` returns 201 with raw API key
- **Superuser blocked from business**: `curl localhost:8080/databases -H "X-API-Key: $SUPERUSER_KEY"` returns 403
- **Unauthenticated rejection**: `curl localhost:8080/databases` (no header) returns 401
- **Public endpoints**: `curl localhost:8080/health` and `curl localhost:8080/openapi.json` return 200 without any key
- **Platform user full access**: A platform-role user can CRUD all databases
- **Product ownership scoping**: A product-role user's `GET /databases` only returns databases where `ownerTeam` matches their team name; `GET /databases/{id}` for a non-owned DB returns 404
- **Revocation**: After `DELETE /users/{id}`, requests with that user's key return 401
- **Cannot revoke superuser**: `DELETE /users/{superuser-id}` returns 403
- **Team deletion guard**: `DELETE /teams/{id}` with active users returns 409 `TEAM_HAS_USERS`
- **Route coverage test** passes with the 6 new paths
- All existing database integration tests pass with API key headers
