# Iteration v0.1 — Foundation (Walking Skeleton)

## Goal
Establish the Go project, dev environment with local K8s + CNPG operator, and a minimal API that proves the Go server can connect to Kubernetes and the CNPG operator.

## Features
- [ ] Tech Stack ADR (`001-tech-stack.md`): Go, HTTP router, K8s client-go, CNPG Go API types, config management, logging, testing decisions
- [ ] Go project scaffolding: `cmd/`, `internal/api/`, `internal/config/`, `internal/k8s/`, `internal/models/` with Go modules initialized and dependencies pinned
- [ ] Dev environment — local K8s cluster: Kind or k3d cluster via Makefile (`make cluster-up`, `make cluster-down`) with CNPG operator auto-installed (`make cnpg-install`)
- [ ] Docker + Compose for the API server: multi-stage Dockerfile (dev + prod), Compose for local dev, `.env.example` with kubeconfig path, namespace, API port
- [ ] Makefile with standard targets: `help`, `setup`, `dev`, `test`, `lint`, `build`, `cluster-up`, `cluster-down`, `cnpg-install` — all idempotent
- [ ] Linting & formatting: golangci-lint config, gofmt, `make lint` passes on clean codebase
- [ ] K8s client configuration: configurable in-cluster (ServiceAccount) or out-of-cluster (kubeconfig path), CNPG typed client using `cloudnative-pg/cloudnative-pg/api/v1`
- [ ] Health check endpoint: `GET /health` returns `{data: {status, version, kubernetes}, error, meta}`, checks K8s connectivity, returns degraded if K8s unreachable
- [ ] Response envelope middleware: all responses wrapped in `{data, error, meta}` format with `requestId` (UUID) and `timestamp` (ISO 8601), structured error handling
- [ ] CI/CD pipeline (GitHub Actions): install, lint, build, test (unit tests only — no K8s in CI)

## Non-Goals
- No database domain model yet
- No CRUD endpoints (beyond health)
- No CNPG resource creation from API (just connectivity proof)

## Dependencies
- Go 1.22+
- Docker + Docker Compose
- Kind or k3d (local K8s)
- CloudNativePG operator
- GitHub Actions

## Acceptance Criteria
- `go build ./...` succeeds and binary starts
- `make cluster-up && make cnpg-install` gives a working K8s cluster with CNPG operator
- `make dev` starts the API server and connects to local K8s
- `make help` lists all targets
- `make lint` passes
- `GET /health` returns 200 with K8s connectivity status
- All responses use the `{data, error, meta}` envelope
- CI pipeline passes on push/PR to main
